[{"title":"快速上手Flask（1）","url":"/2023/01/11/Python%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFlask%EF%BC%881%EF%BC%89/","content":"\n这里以最简单的Flask应用为例，对其进行逐步分析\n\n一、 分析最简单的Flask应用from flask import Flask app = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():  # put application&#x27;s code here    return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n 按照Official Docs的指引，上述代码意思如下：\n\nfrom flask import Flask ：导入 Flask 类，该类的实例将会成为WSGI 应用\napp =  Flask(__name__)：创建Flask的实例——app。第一个参数（这里是__name__）是应用模块的名称， __name__ 是一个适用于大多数情况的快捷方式。正是由于这个参数， Flask 才能知道在哪里可以找到模板和静态文件等东西。\n@app.route(&#39;/&#39;)：route()是装饰器，用于告知Flask触发函数的URL。\nreturn &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot; ：函数返回的内容是在用户浏览器中显示的信息。默认的内容类型是 HTML ，因此字 符串中的 HTML 会被浏览器渲染。\n\n二、  路由（route）\n一般使用 route() 装饰器来把函数绑定到 URL\n\n2.1 静态URL路由（route）分析代码示例：\n@app.route(&#x27;/hello&#x27;)def hello():    return &#x27;Hello, World&#x27;\n\n当访问example/hello时，网页会显示Hello, World\n\n即是路由函数中的“&#x2F;hello”是一个触发字段，当检测到该字段就会返回该函数（这里是def hello()）中返回的html内容(这里是&#39;Hello, World&#39;)\n2.2 动态URL路由（route）分析\n通过把 URL 的一部分标记为 &lt;variable_name&gt; 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。\n\n代码示例：\nfrom markupsafe import escape@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username):    # show the user profile for that user    return f&#x27;User &#123;username&#125;&#x27;\n\n当访问example/user/+任意字符时，网页所返回的显示也是User + 任意字符\n\n2.3 动态URL路由（route）之变量转换规则\n通过使用 &lt;converter:variable_name&gt; ，可以 选择性的加上一个转换器，为变量指定规则。\n\n代码示例：\n@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id):    # show the post with the given id, the id is an integer    return f&#x27;Post &#123;post_id&#125;&#x27;\n\n只有当访问example/post/+整型（int）数字时，网页才会接受，并显示Post + 输入的数字\n\n\n\n\n\n转换类型\n含义\n\n\n\nstring\n(缺省值&#x2F;default value)接受任何不包含斜杠的文本\n\n\nint\n接受正整数\n\n\nfloat\n接受正浮点数\n\n\npath\n类似string，但是可以包含斜杠\n\n\nuuid\n接受uuid字符串\n\n\n注：\nuuid：通用唯一识别码，是用于计算机体系中以识别信息的一个128位标识符。\n缺省：即是默认值，早年由于翻译原因读作缺省。\n2.4 URL路由（route）之重定向行为与URL的唯一性\nFlask对于某些URL会进行重定向，指向文件夹、文件\n\n代码示例：\n@app.route(&#x27;/projects/&#x27;)def projects():    return &#x27;The project page&#x27;\n\n\nprojects() 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹：当访问一个没有斜杠结尾的 URL （ /projects ）时 Flask 会自动进行重 定向，帮您在尾部加上一个斜杠（ /projects/ ）\n\nabout() 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似：如果访问这 个 URL 时添加了尾部斜杠（/about/ ）就会得到一个 404 “未找到” 错 误。这样可以保持 URL 唯一，并有助于搜索引擎重复索引同一页面。\n\n\n2.5 URL构建函数：url_for()\nurl_for() 函数用于构建指定函数的 URL。它把函数名称作为第一个 参数。它可以接受任意个关键字参数，每个关键字参数对应 URL 中的变量。未知变量 将添加到 URL 中作为查询参数。\n\n代码示例：\nwith app.test_request_context():    print(url_for(&#x27;index&#x27;))     # [output]:/    print(url_for(&#x27;login&#x27;))     # [output]:/login    print(url_for(&#x27;login&#x27;, next=&#x27;/&#x27;))     # [output]:/login?next/    print(url_for(&#x27;profile&#x27;, username=&#x27;John Doe&#x27;))     # [output]:/user/John%20Doe\n\n从执行结果上来看，就是字面意思，构建URL。\n2.6 路由（route）HTTP 方法\nWeb 应用使用不同的 HTTP 方法处理 URL 。 缺省情况下，一个路由只回应 GET 请求。\n\n可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法。\n代码示例：\nfrom flask import request@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;POST&#x27;:        return do_the_login()    else:        return show_the_login_form()\n\n这段代码是一个 Flask 应用程序中的一个视图函数, 它定义了一个路由 ‘&#x2F;login’ ，并且可以接受 GET 和 POST 方法的请求。\n\n当请求的方法是 “POST” 时，将会调用 do_the_login() 函数，这个函数可能会处理用户的登录请求,如验证用户名和密码等.\n\n当请求的方法是 “GET” 时，将会调用 show_the_login_form() 函数，这个函数可能会返回一个登录表单的 HTML 页面。\n\n\n概括来说：当用户访问 ‘&#x2F;login’ 页面的时候，如果是 GET 方法将会返回登录表单页面，而如果是 POST 方法将会进行登录操作。\n2.7 路由（route）静态文件\n动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件。理想情况下,服务器已经配置好了为用户提供静态文件的服务。但是在开发过程中， Flask 也能做好 这项工作。只要在包或模块旁边创建一个名为 static 的文件夹就行。\n\n使用特定的 &#39;static&#39; 端点就可以生成相应的 URL。\n代码示例：\nurl_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;)# style.css所在位置：static/style.css\n\n2.8 路由（route）渲染模板\n在 Python 内部生成 HTML 相当笨拙。因为必须自己负责 HTML 转义， 以确保应用的安全。因此， Flask 自动为开发者配置 Jinja2 模板引擎。\n\n使用 render_template() 方法可以渲染模板，只要开发者提供模板名称和需要作为参数传递给模板的变量就行了。\n代码示例：\nfrom flask import render_template@app.route(&#x27;/hello/&#x27;)@app.route(&#x27;/hello/&lt;name&gt;&#x27;)def hello(name=None):    return render_template(&#x27;hello.html&#x27;, name=name)\n\nFlask 会在 templates 文件夹内寻找模板。\n此代码中的文件结构大致如下：\n/app.py/templates    /hello.html\n\n当模板代码如下时（hello.html）：\n&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125;  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125;  &lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endif %&#125;\n\n\n\n当访问example/hello/+任意字符时（图片里是templates），网页显示结果是：Hello templates!\n\n三、操作请求数据3.1 请求对象（request()）这里以具体的实例来认识request()\n代码示例：\n@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def login():    error = None    if request.method == &#x27;POST&#x27;:        if valid_login(request.form[&#x27;username&#x27;],                       request.form[&#x27;password&#x27;]):            return log_the_user_in(request.form[&#x27;username&#x27;])        else:            error = &#x27;Invalid username/password&#x27;    # the code below is executed if the request method    # was GET or the credentials were invalid    return render_template(&#x27;login.html&#x27;, error=error)\n\n这里定义了一个登录路由（/login），并且可以接受两种请求：post、get：\n@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;, &#39;GET&#39;])\n整个login()实现的行为如下：\n如果请求方法是POST，并且表单数据form中的username和password都能通过函数valid_login()的有效性验证，则调用函数log_the_user_in()进行登录行为；若表单数据form中的username和password不能通过有效性验证，则会返回错误信息Invalid username/password。\n如果请求的方法是 “GET” ，将会调用 render_template() 函数来渲染一个名为 ‘login.html’ 的模板。这个模板可能会显示一个登录表单，并且如果 error 变量有值，就会显示一个错误消息。\n3.2 文件上传\n用 Flask 处理文件上传要确保不要忘记在HTML 表单中设置 enctype=&quot;multipart/form-data&quot; 属性就可以了。否则浏览器将不会传送文件。\n\n已上传的文件被储存在内存或文件系统的临时位置。可以通过请求对象 files 属性来访问上传的文件。每个上传的文件都储存在这个 字典型属性中。这个属性基本和标准 Python file 对象一样，另外多出一个 用于把上传文件保存到服务器的文件系统中的 save() 方法。\n代码示例：\nfrom flask import request@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload_file():    if request.method == &#x27;POST&#x27;:        f = request.files[&#x27;the_file&#x27;]        f.save(&#x27;/var/www/uploads/uploaded_file.txt&#x27;)    ...\n\n这段代码定义了一个名为 upload_file() 的视图函数，它处理 ‘&#x2F;upload’ 路由。这个路由能够接受 GET 和 POST 方法的请求。\n当请求方法是 “POST” 时，它会获取请求中上传的文件，使用 request.files 字典获取到上传的文件。这个字典中的键是表单中文件字段的名称，值是一个 FileStorage 对象。在这个例子中,表单中文件字段的名称是 ‘the_file’，所以代码中使用 request.files[‘the_file’] 获取上传的文件。\n接下来,调用 FileStorage 对象的 save() 方法将文件保存到指定的路径 ‘&#x2F;var&#x2F;www&#x2F;uploads&#x2F;uploaded_file.txt’ 中。这个 save() 方法会把文件的内容读取到内存中，然后写入到磁盘中。\n如果想要把客户端的文件名作为服务器上的文件名，可以使用 filename 属性。\n代码示例如下：\n@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload_file():    if request.method == &#x27;POST&#x27;:        file = request.files[&#x27;the_file&#x27;]        file.save(f&quot;/var/www/uploads/&#123;secure_filename(file.filename)&#125;&quot;)    ...\n\n3.3 Cookies\n要访问 cookies ，可以使用 cookies 属性。\n\n可以使用响应 对象 的 set_cookie 方法来设置 cookies 。请求对象的 cookies 属性是一个包含了客户端传输的所有 cookies 的字典。\n\n读取cookies：\n\n代码示例：\nfrom flask import request@app.route(&#x27;/&#x27;)def index():    username = request.cookies.get(&#x27;username&#x27;)    # use cookies.get(key) instead of cookies[key] to not get a KeyError if the cookie is missing.\n\n\n储存cookies：\n\n代码示例：\nfrom flask import make_response@app.route(&#x27;/&#x27;)def index():    resp = make_response(render_template(...))    resp.set_cookie(&#x27;username&#x27;, &#x27;the username&#x27;)    return resp\n\n四、重定向和错误4.1 重定向（redirect()）\n使用 redirect() 函数可以重定向。使用 abort() 可以 更早退出请求，并返回错误代码\n\n代码示例：\nfrom flask import abort, redirect, url_for@app.route(&#x27;/&#x27;)def index():    return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/login&#x27;)def login():    abort(401)    this_is_never_executed()\n\n当用户请求应用程序的根目录路由 ‘&#x2F;‘ 时，index() 函数会被调用。在函数中,使用 redirect() 函数重定向请求到路由 ‘&#x2F;login’ 上。这个函数接受一个 URL 作为参数,并在浏览器中重定向到这个 URL。在这个例子中,使用 url_for() 函数来获取 login 视图函数对应的 URL。\n当请求重定向到路由 ‘&#x2F;login’ 时，login() 函数会被调用。在这个函数中，使用 abort() 函数终止请求并返回一个状态码为 401 的响应。401状态码表示请求需要身份验证，因此这个函数会返回一个未授权的响应。\n4.2 错误\n缺省情况下每种出错代码都会对应显示一个黑白的出错页面。\n\n使用 errorhandler() 装饰器可以定制出错页面。\n代码示例：\n@app.errorhandler(404)def page_not_found(error):    return render_template(&#x27;page_not_found.html&#x27;), 404\n\n一般情况下，200表示一切正常。\n4.3 JSON 格式的 API代码示例：\n@app.route(&quot;/me&quot;)def me_api():    user = get_current_user()    return &#123;        &quot;username&quot;: user.username,        &quot;theme&quot;: user.theme,        &quot;image&quot;: url_for(&quot;user_image&quot;, filename=user.image),    &#125;\n\n在函数中, 首先使用 get_current_user() 函数获取当前用户的信息，并将其赋值给变量 user。\n然后，函数返回一个字典对象，其中包含了用户的用户名、主题和图像的相关信息。其中, “username”: user.username 表示用户名, “theme”: user.theme 表示用户的主题。\n最后,”image”: url_for(“user_image”, filename&#x3D;user.image) 返回一个能够访问用户图像的 URL。它使用 url_for() 函数生成一个 URL,该URL 是访问名为 “user_image” 的视图函数，并且指定了文件名为 user.image 的参数。\n五、会话\n除了请求对象之外还有一种称为 session 的对象，允许在不同请求 之间储存信息。\n这个对象相当于用密钥签名加密的 cookie ，即用户可以查看 cookie ，但是如果没有密钥就无法修改它。\n\n注意：使用会话之前您必须设置一个密钥。\n代码示例：\nfrom flask import session# Set the secret key to some random bytes. Keep this really secret!app.secret_key = b&#x27;_5#y2L&quot;F4Q8z\\n\\xec]/&#x27;@app.route(&#x27;/&#x27;)def index():    if &#x27;username&#x27; in session:        return f&#x27;Logged in as &#123;session[&quot;username&quot;]&#125;&#x27;    return &#x27;You are not logged in&#x27;@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;POST&#x27;:        session[&#x27;username&#x27;] = request.form[&#x27;username&#x27;]        return redirect(url_for(&#x27;index&#x27;))    return &#x27;&#x27;&#x27;        &lt;form method=&quot;post&quot;&gt;            &lt;p&gt;&lt;input type=text name=username&gt;            &lt;p&gt;&lt;input type=submit value=Login&gt;        &lt;/form&gt;    &#x27;&#x27;&#x27;@app.route(&#x27;/logout&#x27;)def logout():    # remove the username from the session if it&#x27;s there    session.pop(&#x27;username&#x27;, None)    return redirect(url_for(&#x27;index&#x27;))\n\n在代码中,首先使用 app.secret_key 来设置一个加密密钥,这个密钥用于加密会话 cookie，保证它们不会被篡改。\n当用户请求应用程序的根目录路由 ‘&#x2F;‘ 时，index() 函数会被调用。在函数中, 使用 session 字典来检查用户是否已经登录。如果 session 中包含 ‘username’ 键，则说明用户已经登录，函数会返回一个包含用户名的字符串。否则，函数会返回一个提示用户未登录的字符串。\n当用户请求登录路由 ‘&#x2F;login’ 时，login() 函数会被调用。如果请求方法是 ‘POST’，说明用户提交了登录表单。在这种情况下,函数会使用 request.form 字典来获取用户名,并将其存储在 session[‘username’] 中。然后,使用 redirect() 函数重定向到根目录路由 ‘&#x2F;‘。如果请求方法是 ‘GET’，函数会返回一个包含登录表单的 HTML 代码的字符串。\n当用户请求注销路由 ‘&#x2F;logout’ 时，logout() 函数会被调用。函数会使用 session.pop() 方法删除 session 中的 ‘username’ 键,并重定向到根目录路由 ‘&#x2F;‘。这样会使用户退出登录。\n六、消息闪现\n现系统的基本工作原理是 在请求结束时记录一个消息，提供且只提供给下一个请求使用。\n\n代码示例：\nfrom flask import Flask, flash, redirect, render_template, \\     request, url_forapp = Flask(__name__)app.secret_key = b&#x27;_5#y2L&quot;F4Q8z\\n\\xec]/&#x27;@app.route(&#x27;/&#x27;)def index():    return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    error = None    if request.method == &#x27;POST&#x27;:        if request.form[&#x27;username&#x27;] != &#x27;admin&#x27; or \\           request.form[&#x27;password&#x27;] != &#x27;secret&#x27;:            error = &#x27;Invalid credentials&#x27;        else:            flash(&#x27;You were successfully logged in&#x27;)            return redirect(url_for(&#x27;index&#x27;))    return render_template(&#x27;login.html&#x27;, error=error)\n\n七、日志\n多数时 候在类似情况下返回 400 Bad Request 就没事了，但也有不会返回的时候， 而代码还得继续运行下去。\n\n代码示例：\napp.logger.debug(&#x27;A value for debugging&#x27;)app.logger.warning(&#x27;A warning occurred (%d apples)&#x27;, 42)app.logger.error(&#x27;An error occurred&#x27;)\n","tags":["Flask类","route"]},{"title":"Python Web 应用程序设计：教务系统（web框架选择 Flask & Django）","url":"/2023/01/11/Python%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%EF%BC%88web%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9%20Flask%20&%20Django%EF%BC%89/","content":"\n随着大四上所有的课程接近尾声，毕业设计也开始逐渐拉上序幕，我的毕业设计是基于Python的教务系统设计，本篇博文围绕此进行展开\n本篇博文创作中遇到了很多困难，感谢 OpenAI Chat Chat 的帮助\n\n一、Flask与Django分别是什么？1.1 Flask 是什么？Flask以Python为逻辑语言，以 Werkzeug WSGI Tool Package、 Jinja2 Engine作为核心引擎，用于构建Web Application Framework应用程序的轻量级框架。\n1.2 Django 是什么？Django 以Python为逻辑语言，以 Model-View-Controller (MVC) 架构为核心构架，主攻用于快速开发安全、可靠和可维护的 Web Application Framework重量级框架。\n二、 相对于Django而言，Flask 的优点是什么？2.1 Flask更简单易用\n Flask 框架的核心部分非常简单，易于理解和使用，适合入门和小型项目。\n\nFlask 框架的核心部分非常简单，主要是因为它没有很多内置功能，它只是一个简单的 web 框架，主要提供了如下功能：\n\n路由系统：用于定义视图函数的 URL 路径。\n模板系统：用于渲染 HTML 模板。\n错误处理：用于处理应用程序中出现的错误。\n请求对象和响应对象：用于处理 HTTP 请求和响应。\n\n这些功能都是基本的 web 框架功能，Flask的设计目的就是让这些功能尽可能简单，易于理解和使用。\n与之对比，Django是一个功能更加丰富的框架，它包括了很多内置的功能，如：\n\n管理数据库的ORM系统\n表单验证和身份验证\n管理后台\n基于类的视图\n……\n\n2.2 Flask灵活性更高\nFlask 提供了很多扩展，你可以根据需要选择性地使用，没有多余的功能限制。（社区提供）\n\nFlask灵活性高，主要是因为它设计成模块化，核心部分非常简单，大部分功能是通过扩展来实现的。这样一来，开发者可以根据自己项目的需求来选择使用哪些扩展。\nFlask扩展可以为应用程序增加很多实用的功能，如：\n\n管理数据库的ORM系统\n表单验证和身份验证\n管理后台\n电子邮件\n图像处理\n……\n\n可以根据项目需求来选择使用哪些扩展，没有多余的功能限制你。\n而与之相比，Django是一个功能更加丰富的框架,它自带很多功能，可能会因为不需要而造成学习负担或者资源浪费。\n这种灵活性能够使开发者更灵活地选择所需要的功能，不会因为不需要而增加学习成本和资源浪费。\n2.3 Flask开发周期更短\n开发周期短：由于 Flask 框架的简单性，可以让开发人员更快地完成项目。\n\n三、 相对于Django而言，Flask 的缺点是什么？3.1 Flask功能有限、扩展性差、不适合做大项目\nFlask 是一个轻量级框架，其内置功能有限，需要使用第三方库才能完成一些常见功能\n\n直白的说，Flask的核心框架简单的优点也是它的缺点。例如管理数据库,表单验证等,如果需要这些功能需要手动添加。\n四、最终选择大致考虑一些，Flask框架更适合做这种非长期维护型项目。主要是不需要考虑安全性、稳定性等维护支持。\n","tags":["Python","教务系统","web","Flask","Django"]},{"title":"初识Hexo","url":"/2023/01/08/%E5%88%9D%E8%AF%86Hexo/","content":"\n此前一直想要搭建属于自己的Blog，正好现在趁着大四上寒假空档期就付诸实践了。\n在搭建中遇到了许多困难，感谢Hexo Installation Doc &amp; Github Action自动部署 &amp; GitHub+Hexo 搭建个人网站详细教程 等文章的帮助\n\n搭建基于 Github 和 Github Action 的Hexo Blog一、遵循Hexo Installation Doc安装Hexo1.1 Install Hexo$ npm install -g hexo-cli\n\n进行此步骤要求电脑上已经安装了npm。在这一步执行完成后可以看到本目录下出现了如下图的目录结构：\n\n二、获取Github Token2.1 进入Github账户设置如图,点击你的Github头像,然后选择 Settings ：\n2.2 进入Developer settings进入设置后，拉到底，点击 Developer settings\n\n2.3 生成token如图，进入 Developer settings 后，选择 Tokens (classic) \n\n如图，然后选择 Generate new token , token 只会在生成时显示，需要将其复制到其他地方先记住\n\n三、更改deploy的仓库地址:_config.yml进入刚才安装 Hexo 的目录，找到 _config.yml ,双击打开，并修改 type &amp; repo 如下项：\ndeploy:  type: git  repo: https://token@github.com/username/username.github.io.git\n\n其中 repo 修改示例为：\n例如，我的github pages仓库https地址是: https://github.com/SoDebug/SoDebug.github.io.git，那么 repo 就修改为: https://token@github.com/SoDebug/SoDebug.github.io.git\n四、连接到Github远程仓库（建议私人仓库）\n其中 Repository name 可随意取，但是仓库类型建议选择 Private 以防止自己账户的API泄露\n然后就是本地链接到该仓库，命令如下（需要本地已经安装git）：\ngit init    #仓库初始化git add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin #（私有仓库的地址）(形如：https://github.com/.../.git)git push -u origin main\n\n至此，本地仓库的源码将同步至刚刚新建立的仓库之中（如提交过程中要求输入用户名和密码，输入即可。）仓库同步后的样子大致如下：\n\n五、开始部署 Github Action 工作流点击 Action 进入如下图界面：\n\n5.1 点击 New workflow进入界面如下\n\n5.2 选择 set up a workflow yourself进入界面如下\n\n将以下代码作相应修改并复制到其中\nname: Deploy # 部署 on: # 触发条件  push:    branches:      - main # 推送到 main 分支（这里的分支名很重要，不要弄错了）   release:    types:      - published # 推送新版本号   workflow_dispatch: # 手动触发 jobs:  build:    runs-on: ubuntu-latest     steps:    - name: Checkout # Checkout 仓库      uses: actions/checkout@v2      with:        ref: main     - name: Setup Node # 安装 Node.js      uses: actions/setup-node@v1      with:        node-version: &quot;12.x&quot;     - name: Install Hexo # 安装 Hexo      run: |        npm install hexo-cli -g    - name: Cache Modules # 缓存 Node 插件      uses: actions/cache@v1      id: cache-modules      with:        path: node_modules        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;     - name: Install Dependencies # 如果没有缓存或 插件有更新，则安装插件      if: steps.cache-modules.outputs.cache-hit != &#x27;true&#x27;      run: | # **如果仓库里没有 package-lock.json，上传一下，npm ci 必须要有 package-lock.json**        npm ci    - name: Generate # 生成      run: |        hexo clean        hexo generate    - name: Deploy # 部署      run: |        git config --global user.name &quot;username&quot;        git config --global user.email &quot;xxxxx@example.com&quot;        git clone 你的Github Pages链接（例如：https://github.com/username/username.github.io.git） .deploy_git        export TZ=&#x27;Asia/Shanghai&#x27;        hexo deploy\n\n5.3 提交 workflow依次点击图中的Start Commit &amp; Commit new file来提交workflow\n\n5.4 检查 Action 运行状况返回 Action 界面，查看 Action 是否正常运行，并且没有报错 \n\n","tags":["Hexo","Github"]}]