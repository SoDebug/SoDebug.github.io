[{"title":"快速上手Flask（1）","url":"/2023/01/11/Python%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8BFlask%EF%BC%881%EF%BC%89/","content":"\n这里以最简单的Flask应用为例，对其进行逐步分析\n\n一、 分析最简单的Flask应用from flask import Flask app = Flask(__name__)@app.route(&#x27;/&#x27;)def hello_world():  # put application&#x27;s code here    return &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot;if __name__ == &#x27;__main__&#x27;:    app.run()\n\n 按照Official Docs的指引，上述代码意思如下：\n\nfrom flask import Flask ：导入 Flask 类，该类的实例将会成为WSGI 应用\napp =  Flask(__name__)：创建Flask的实例——app。第一个参数（这里是__name__）是应用模块的名称， __name__ 是一个适用于大多数情况的快捷方式。正是由于这个参数， Flask 才能知道在哪里可以找到模板和静态文件等东西。\n@app.route(&#39;/&#39;)：route()是装饰器，用于告知Flask触发函数的URL。\nreturn &quot;&lt;p&gt;Hello, World!&lt;/p&gt;&quot; ：函数返回的内容是在用户浏览器中显示的信息。默认的内容类型是 HTML ，因此字 符串中的 HTML 会被浏览器渲染。\n\n二、  路由（route）\n一般使用 route() 装饰器来把函数绑定到 URL\n\n2.1 静态URL路由（route）分析代码示例：\n@app.route(&#x27;/hello&#x27;)def hello():    return &#x27;Hello, World&#x27;\n\n当访问example/hello时，网页会显示Hello, World\n![1.2.1_1](.&#x2F;..&#x2F;images&#x2F;Python Web 应用程序设计：快速上手Flask（1）&#x2F;1.2.1_1.png)\n即是路由函数中的“&#x2F;hello”是一个触发字段，当检测到该字段就会返回该函数（这里是def hello()）中返回的html内容(这里是&#39;Hello, World&#39;)\n2.2 动态URL路由（route）分析\n通过把 URL 的一部分标记为 &lt;variable_name&gt; 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。\n\n代码示例：\nfrom markupsafe import escape@app.route(&#x27;/user/&lt;username&gt;&#x27;)def show_user_profile(username):    # show the user profile for that user    return f&#x27;User &#123;username&#125;&#x27;\n\n当访问example/user/+任意字符时，网页所返回的显示也是User + 任意字符\n![1.2.2_1](.&#x2F;..&#x2F;images&#x2F;Python Web 应用程序设计：快速上手Flask（1）&#x2F;1.2.2_1.png)\n2.3 动态URL路由（route）之变量转换规则\n通过使用 &lt;converter:variable_name&gt; ，可以 选择性的加上一个转换器，为变量指定规则。\n\n代码示例：\n@app.route(&#x27;/post/&lt;int:post_id&gt;&#x27;)def show_post(post_id):    # show the post with the given id, the id is an integer    return f&#x27;Post &#123;post_id&#125;&#x27;\n\n只有当访问example/post/+整型（int）数字时，网页才会接受，并显示Post + 输入的数字\n![image-20230112123516620](.&#x2F;..&#x2F;images&#x2F;Python Web 应用程序设计：快速上手Flask（1）&#x2F;image-20230112123516620.png)\n![image-20230112123536016](.&#x2F;..&#x2F;images&#x2F;Python Web 应用程序设计：快速上手Flask（1）&#x2F;image-20230112123536016.png)\n\n\n\n转换类型\n含义\n\n\n\nstring\n(缺省值&#x2F;default value)接受任何不包含斜杠的文本\n\n\nint\n接受正整数\n\n\nfloat\n接受正浮点数\n\n\npath\n类似string，但是可以包含斜杠\n\n\nuuid\n接受uuid字符串\n\n\n注：\nuuid：通用唯一识别码，是用于计算机体系中以识别信息的一个128位标识符。\n缺省：即是默认值，早年由于翻译原因读作缺省。\n2.4 URL路由（route）之重定向行为与URL的唯一性\nFlask对于某些URL会进行重定向，指向文件夹、文件\n\n代码示例：\n@app.route(&#x27;/projects/&#x27;)def projects():    return &#x27;The project page&#x27;\n\n\nprojects() 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹：当访问一个没有斜杠结尾的 URL （ /projects ）时 Flask 会自动进行重 定向，帮您在尾部加上一个斜杠（ /projects/ ）\n\nabout() 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似：如果访问这 个 URL 时添加了尾部斜杠（/about/ ）就会得到一个 404 “未找到” 错 误。这样可以保持 URL 唯一，并有助于搜索引擎重复索引同一页面。\n\n\n2.5 URL构建函数：url_for()\nurl_for() 函数用于构建指定函数的 URL。它把函数名称作为第一个 参数。它可以接受任意个关键字参数，每个关键字参数对应 URL 中的变量。未知变量 将添加到 URL 中作为查询参数。\n\n代码示例：\nwith app.test_request_context():    print(url_for(&#x27;index&#x27;))     # [output]:/    print(url_for(&#x27;login&#x27;))     # [output]:/login    print(url_for(&#x27;login&#x27;, next=&#x27;/&#x27;))     # [output]:/login?next/    print(url_for(&#x27;profile&#x27;, username=&#x27;John Doe&#x27;))     # [output]:/user/John%20Doe\n\n从执行结果上来看，就是字面意思，构建URL。\n2.6 路由（route）HTTP 方法\nWeb 应用使用不同的 HTTP 方法处理 URL 。 缺省情况下，一个路由只回应 GET 请求。\n\n可以使用 route() 装饰器的 methods 参数来处理不同的 HTTP 方法。\n代码示例：\nfrom flask import request@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login():    if request.method == &#x27;POST&#x27;:        return do_the_login()    else:        return show_the_login_form()\n\n这段代码是一个 Flask 应用程序中的一个视图函数, 它定义了一个路由 ‘&#x2F;login’ ，并且可以接受 GET 和 POST 方法的请求。\n\n当请求的方法是 “POST” 时，将会调用 do_the_login() 函数，这个函数可能会处理用户的登录请求,如验证用户名和密码等.\n\n当请求的方法是 “GET” 时，将会调用 show_the_login_form() 函数，这个函数可能会返回一个登录表单的 HTML 页面。\n\n\n概括来说：当用户访问 ‘&#x2F;login’ 页面的时候，如果是 GET 方法将会返回登录表单页面，而如果是 POST 方法将会进行登录操作。\n2.7 路由（route）静态文件\n动态的 web 应用也需要静态文件，一般是 CSS 和 JavaScript 文件。理想情况下,服务器已经配置好了为用户提供静态文件的服务。但是在开发过程中， Flask 也能做好 这项工作。只要在包或模块旁边创建一个名为 static 的文件夹就行。\n\n使用特定的 &#39;static&#39; 端点就可以生成相应的 URL。\n代码示例：\nurl_for(&#x27;static&#x27;, filename=&#x27;style.css&#x27;)# style.css所在位置：static/style.css\n\n2.8 路由（route）渲染模板\n在 Python 内部生成 HTML 相当笨拙。因为必须自己负责 HTML 转义， 以确保应用的安全。因此， Flask 自动为开发者配置 Jinja2 模板引擎。\n\n使用 render_template() 方法可以渲染模板，只要开发者提供模板名称和需要作为参数传递给模板的变量就行了。\n代码示例：\nfrom flask import render_template@app.route(&#x27;/hello/&#x27;)@app.route(&#x27;/hello/&lt;name&gt;&#x27;)def hello(name=None):    return render_template(&#x27;hello.html&#x27;, name=name)\n\nFlask 会在 templates 文件夹内寻找模板。\n此代码中的文件结构大致如下：\n/app.py/templates    /hello.html\n\n当模板代码如下时（hello.html）：\n&lt;!doctype html&gt;&lt;title&gt;Hello from Flask&lt;/title&gt;&#123;% if name %&#125;  &lt;h1&gt;Hello &#123;&#123; name &#125;&#125;!&lt;/h1&gt;&#123;% else %&#125;  &lt;h1&gt;Hello, World!&lt;/h1&gt;&#123;% endif %&#125;\n\n\n\n当访问example/hello/+任意字符时（图片里是templates），网页显示结果是：Hello templates!\n![image-20230112145522169](.&#x2F;..&#x2F;images&#x2F;Python Web 应用程序设计：快速上手Flask（1）&#x2F;image-20230112145522169.png)\n","tags":["Flask类","route"]},{"title":"Python Web 应用程序设计：教务系统（web框架选择 Flask & Django）","url":"/2023/01/11/Python%20Web%20%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%EF%BC%88web%E6%A1%86%E6%9E%B6%E9%80%89%E6%8B%A9%20Flask%20&%20Django%EF%BC%89/","content":"\n随着大四上所有的课程接近尾声，毕业设计也开始逐渐拉上序幕，我的毕业设计是基于Python的教务系统设计，本篇博文围绕此进行展开\n本篇博文创作中遇到了很多困难，感谢 OpenAI Chat Chat 的帮助\n\n一、Flask与Django分别是什么？1.1 Flask 是什么？Flask以Python为逻辑语言，以 Werkzeug WSGI Tool Package、 Jinja2 Engine作为核心引擎，用于构建Web Application Framework应用程序的轻量级框架。\n1.2 Django 是什么？Django 以Python为逻辑语言，以 Model-View-Controller (MVC) 架构为核心构架，主攻用于快速开发安全、可靠和可维护的 Web Application Framework重量级框架。\n二、 相对于Django而言，Flask 的优点是什么？2.1 Flask更简单易用\n Flask 框架的核心部分非常简单，易于理解和使用，适合入门和小型项目。\n\nFlask 框架的核心部分非常简单，主要是因为它没有很多内置功能，它只是一个简单的 web 框架，主要提供了如下功能：\n\n路由系统：用于定义视图函数的 URL 路径。\n模板系统：用于渲染 HTML 模板。\n错误处理：用于处理应用程序中出现的错误。\n请求对象和响应对象：用于处理 HTTP 请求和响应。\n\n这些功能都是基本的 web 框架功能，Flask的设计目的就是让这些功能尽可能简单，易于理解和使用。\n与之对比，Django是一个功能更加丰富的框架，它包括了很多内置的功能，如：\n\n管理数据库的ORM系统\n表单验证和身份验证\n管理后台\n基于类的视图\n……\n\n2.2 Flask灵活性更高\nFlask 提供了很多扩展，你可以根据需要选择性地使用，没有多余的功能限制。（社区提供）\n\nFlask灵活性高，主要是因为它设计成模块化，核心部分非常简单，大部分功能是通过扩展来实现的。这样一来，开发者可以根据自己项目的需求来选择使用哪些扩展。\nFlask扩展可以为应用程序增加很多实用的功能，如：\n\n管理数据库的ORM系统\n表单验证和身份验证\n管理后台\n电子邮件\n图像处理\n……\n\n可以根据项目需求来选择使用哪些扩展，没有多余的功能限制你。\n而与之相比，Django是一个功能更加丰富的框架,它自带很多功能，可能会因为不需要而造成学习负担或者资源浪费。\n这种灵活性能够使开发者更灵活地选择所需要的功能，不会因为不需要而增加学习成本和资源浪费。\n2.3 Flask开发周期更短\n开发周期短：由于 Flask 框架的简单性，可以让开发人员更快地完成项目。\n\n三、 相对于Django而言，Flask 的缺点是什么？3.1 Flask功能有限、扩展性差、不适合做大项目\nFlask 是一个轻量级框架，其内置功能有限，需要使用第三方库才能完成一些常见功能\n\n直白的说，Flask的核心框架简单的优点也是它的缺点。例如管理数据库,表单验证等,如果需要这些功能需要手动添加。\n四、最终选择大致考虑一些，Flask框架更适合做这种非长期维护型项目。主要是不需要考虑安全性、稳定性等维护支持。\n","tags":["Python","教务系统","web","Flask","Django"]},{"title":"初识Hexo","url":"/2023/01/08/%E5%88%9D%E8%AF%86Hexo/","content":"\n此前一直想要搭建属于自己的Blog，正好现在趁着大四上寒假空档期就付诸实践了。\n在搭建中遇到了许多困难，感谢Hexo Installation Doc &amp; Github Action自动部署 &amp; GitHub+Hexo 搭建个人网站详细教程 等文章的帮助\n\n搭建基于 Github 和 Github Action 的Hexo Blog一、遵循Hexo Installation Doc安装Hexo1.1 Install Hexo$ npm install -g hexo-cli\n\n进行此步骤要求电脑上已经安装了npm。在这一步执行完成后可以看到本目录下出现了如下图的目录结构：\n\n二、获取Github Token2.1 进入Github账户设置如图,点击你的Github头像,然后选择 Settings ：\n2.2 进入Developer settings进入设置后，拉到底，点击 Developer settings\n\n2.3 生成token如图，进入 Developer settings 后，选择 Tokens (classic) \n\n如图，然后选择 Generate new token , token 只会在生成时显示，需要将其复制到其他地方先记住\n\n三、更改deploy的仓库地址:_config.yml进入刚才安装 Hexo 的目录，找到 _config.yml ,双击打开，并修改 type &amp; repo 如下项：\ndeploy:  type: git  repo: https://token@github.com/username/username.github.io.git\n\n其中 repo 修改示例为：\n例如，我的github pages仓库https地址是: https://github.com/SoDebug/SoDebug.github.io.git，那么 repo 就修改为: https://token@github.com/SoDebug/SoDebug.github.io.git\n四、连接到Github远程仓库（建议私人仓库）\n其中 Repository name 可随意取，但是仓库类型建议选择 Private 以防止自己账户的API泄露\n然后就是本地链接到该仓库，命令如下（需要本地已经安装git）：\ngit init    #仓库初始化git add .git commit -m &quot;first commit&quot;git branch -M maingit remote add origin #（私有仓库的地址）(形如：https://github.com/.../.git)git push -u origin main\n\n至此，本地仓库的源码将同步至刚刚新建立的仓库之中（如提交过程中要求输入用户名和密码，输入即可。）仓库同步后的样子大致如下：\n\n五、开始部署 Github Action 工作流点击 Action 进入如下图界面：\n\n5.1 点击 New workflow进入界面如下\n\n5.2 选择 set up a workflow yourself进入界面如下\n\n将以下代码作相应修改并复制到其中\nname: Deploy # 部署 on: # 触发条件  push:    branches:      - main # 推送到 main 分支（这里的分支名很重要，不要弄错了）   release:    types:      - published # 推送新版本号   workflow_dispatch: # 手动触发 jobs:  build:    runs-on: ubuntu-latest     steps:    - name: Checkout # Checkout 仓库      uses: actions/checkout@v2      with:        ref: main     - name: Setup Node # 安装 Node.js      uses: actions/setup-node@v1      with:        node-version: &quot;12.x&quot;     - name: Install Hexo # 安装 Hexo      run: |        npm install hexo-cli -g    - name: Cache Modules # 缓存 Node 插件      uses: actions/cache@v1      id: cache-modules      with:        path: node_modules        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;     - name: Install Dependencies # 如果没有缓存或 插件有更新，则安装插件      if: steps.cache-modules.outputs.cache-hit != &#x27;true&#x27;      run: | # **如果仓库里没有 package-lock.json，上传一下，npm ci 必须要有 package-lock.json**        npm ci    - name: Generate # 生成      run: |        hexo clean        hexo generate    - name: Deploy # 部署      run: |        git config --global user.name &quot;username&quot;        git config --global user.email &quot;xxxxx@example.com&quot;        git clone 你的Github Pages链接（例如：https://github.com/username/username.github.io.git） .deploy_git        export TZ=&#x27;Asia/Shanghai&#x27;        hexo deploy\n\n5.3 提交 workflow依次点击图中的Start Commit &amp; Commit new file来提交workflow\n\n5.4 检查 Action 运行状况返回 Action 界面，查看 Action 是否正常运行，并且没有报错 \n\n","tags":["Hexo","Github"]}]